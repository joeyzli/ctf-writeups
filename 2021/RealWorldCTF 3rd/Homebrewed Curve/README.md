# RealWorldCTF 3rd - Homebrewed Curve

* **Category:** Crypto
* **Points:** 171

## Challenge

>They warned me do not choose my own curve since a bad curve's security is no stronger than the underlying field. So I choose very large prime to make it secure again.

## Solution

We are given the following program(chal.py):

```python
#!/usr/bin/env python3

import random
import hashlib

from libnum import invmod
from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes
from Crypto.Util.Padding import pad

from secret import FLAG, P

class Curve:

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def add(self, p1, p2):
        if p1 == self.zero:
            return p2

        if p2 == self.zero:
            return p1

        x1, y1 = p1
        x2, y2 = p2

        if x1 != x2:
            l = (y2 - y1) * invmod(x2 - x1, P)
        else:
            l = 2 * self.a * x1 + self.b #curves of the form y = ax^2 + bx.. but this doesn't have the nice addition property.

        x = ((l - self.b) * invmod(self.a, P) - self.zero[0]) % P
        y = ((x - self.zero[0]) * l + self.zero[1]) % P

        return (x, y)

    def mul(self, p1, n):
        if n == 0 or p1 == self.zero:
            return self.zero

        res = self.zero
        while n:
            if n & 1:
                res = self.add(res, p1)
            p1 = self.add(p1, p1)
            n >>= 1
        return res

    def gen_key(self):
        sk = random.randint(1, P)
        pk = self.mul(self.gen, sk)
        return sk, pk

curve = Curve(
    a=338105350242668308929697763396044301660,
    b=70631159681042046635446173236982478064116538177970218795092411634131296885767,
    zero=(9754705134713370500425418962906364916694128219443986534870265438313712052553913556304578048773182865236181393234774811636563665254738358548547686098321918938336999994543320310489785839068889289585561389237322554300534800377365494547910434446171077511660646734142974631896227159038644834795595939445003783184271907835168083982210804135992472981458997056367475361358045062954295385753362817510369968941277639065938619221482008127361125972584968230982231483416783792258479416113581249377750311129019561848383083514672254514692875070293706012921153875918378772956871354902564753931679232128607231527456371560574893648150, 1568631189076775839914050721386821274436631828518639911590203429753674249963724465949098434816249858592209181914562366684848647341809527620103035336678319490054708958682690371323396425059326761139960520329829342510826324634871361342587962617109233961205192373716747727013613655062002124851676969800006190929713777159839273173689438005523473921392011053323705509027606365967531781465002057406686284573053674133382181877418753925610208463393821516137543581472014268533517599374830226690216017114664929426655189944119312800402788151756994817725042844409983509754618168400455155658767237036605650525875166823462486072842),
    gen=(12532998589621080097666945122441206260965625062664570083674602252675892295679594034580389931735096079697125441246960301905307858329289188790029626634485829771734823159182904621402737540757430079518142479215838577833498703259391220160619426650385355407344355318793784733990238754982178179201863773450543367485332580658467529082154218982726945799974265641603861234501912638573835723384717842487988638277214429988591192513007462677389252245306874828268739787612245357189986581131725474432904172834643657027954405787429995826738074015516166702962206858859896933459093477305874443350335332968385035927605359630747331204285, 9677982578222119974363478748399786948047636069661692206522662047830643067492306311529114015320387572903840619331518584584400368845497864412752196098241604714699115186432809693851692194762433385961429711487895639093866274072187416400859677893102613898063134064507994013600600120524875666883108971040402000931357050726739367647257578379098507781478457700720118945453670136245178829199722575486626106268256525611370267664890630521019846806960099333376121482220389744953231843397729642415527736926160072478730239575933321480584291410141867063436921546657245313608614224909988684794138541856898030369431518091733072867437),
)

ak, A = curve.gen_key()
bk, B = curve.gen_key()

print(A)
print(B)

shared = curve.mul(A, bk)[0]
key = hashlib.sha256(long_to_bytes(shared)).digest()
aes = AES.new(key, AES.MODE_ECB)
ciphertext = aes.encrypt(pad(FLAG, AES.block_size))
print(ciphertext.hex())
```
as well as the output from running the program(output.txt):
```(13487441097225225851381503721250882201348230291456769111220742564976603915541284733903445742010369949564133835184041848270925618065093927905336977954164490448790585095635629931682025014174873840946833423568776772534204109608898522472240761836716148677237778503440395160725865443571787537094238702604760374819569040510617361718394064021678094989416987996196517169045682067813960280671702291412278502544773112916378850480939772300572998243270196397238062178930871026435948325839912933370726600147757455774532767943291746849500590032985576917021393256167765909741347168603316800970606576192321995775188693736786445970160, 6017599616030668129613886703128129222334636061709939196813507723707943475088184604346025813500691639135280058944967720252980654491495661264318199620883475540203205404460632231139796107580037387665375828311005986158345466234113715267437612091657183380072338306002369357139146048822354864239891700619714889347124655297444781747932429314301652892318820172915980583258019186234125036141716353634569644160769758113796289362452914192384749373824618193948698071662955348463507865825856345882176096759589399552633775680285990970529819948425052395988810137569926613717988817522119415329098727602713461364878132364924903122354)
(12325243140409509948390016947224835770037275709809199983863357504628092935405755615708471085146623088629930125222768275569249161772533262995997384602018963893791998430652960945216562316807507576074802113883850941124224565729858452198366295197883539144659809879585978117675682586217166877317417820588576087650344398633914868028869563804325425499084148917013752420468723286815504458371864930365680607878997170362726942929241087236675902387482097261010616327896296714705736419010609802542459944267215680522857179358080459237676786115966499799125501709118451402926712061906091422526053306629229053727883903005288795696508, 11505268856676087471457416848355426459576355205947042999067185842545620763588462278320812379117467263916383145249098261720386127003988544590766801168503624732272757534718035824926881081717465079216152838849559029603087971046414561166054241351336879142412362035493311540826692018441037485743070162688102587726966007813519178658355297714620527127226989353344537573502931404623687629851431286618067819135715913162892925109669537524861927815259765868576488623808219606831381696710149107337624587114848589866865509992514440834069577162069420625328534884840613305250527515798029474049312705531575693278171514006918716216130)
1c002f8ecfa9177ffed879245681dbb606ed194f319c12a0a0940c7193e490095e9915d9ce9252f8377def6a92bcab6a
```

The challenge can be broken down into 3 parts: Finding the type of curve, finding the secret prime `P`, and finding the shared secret by solving what appears to be a discrete logarithm problem(DLP).

Looking at `chal.py`, we see that the `Curve` class provided looks similar to an elliptic curve, aside from the `add` function, which has a few differences:
* When the two points share the same x, `l = 2ax + b` instead of `(3x^2 + A)/2y`
* The x and y of the resulting point are also different from the calculation done with standard elliptic curves.

Notably, the addition algorithm does not check whether both the x and y for two points are equal, only checking the x. This hints that there is only one y for each x, and thus also only one point for each x. Further, the equal points case with usual elliptic curve point addition has its equation come from taking the derivative of y with respect to x to get the tangent slope at the point, meaning that we might be able to apply the same logic to our curve here. Doing this gets the parabola `y = ax^2 + bx`, with some possible other constant added. However, this on its own is not enough, as the final calculation for the resulting point's x and y is also different. So, to check the equation for our curve, we can use the provided equations for x and y.

We will write `zero[0]` as `Ox` and `zero[1]` as `Oy`. Solving for `l` in the `x` equation yields `l = a(x + Ox) + b`. Plugging this in for `l` in the `y` equation gives us `y = a(x^2 - Ox^2) + b(x - Ox) + Oy`. This confirms our earlier findings.

Knowing the curve equation, we can now recover `P`. We can do this by seeing that our curve is really defined by `y = a(x^2 - Ox^2) + b(x - Ox) + Oy mod P`. We can rearrange to get that `a(x^2 - Ox^2) + b(x - Ox) + Oy - y = 0 mod P`, which we can lift to get `a(x^2 - Ox^2) + b(x - Ox) + Oy - y = kP` for some k. For each of the points given to us, being `A`, `B`, `zero`, and `gen`, we can do this to get different multiples of p. We then use `gcd` to recover `P`, or some small multiple of it. In this case, I got a small multiple of `P`, so I used Sagemath to factor it and get `P = 16964155551072495694293641975607630224727620299506094680698561697517114055981456463802735036670824528486635128253757386796419676408241481233714972382812783160754601985902695360703612064223677630625126592834772106201583720344150312382723959316671117708799304253580291408927697557459674805267132980104779404642276846095233729275890317878916892907703929715499923974553217760175425647369679697361138159243363407958468903965694813367459663590914481184614924748816307473556323329341018650081832249242635801731713869201574073433674020290004290751530577883843107369211669006291178070342858539229191025760918841972906522445981`. I also used `gmpy2`'s `is_prime` function to verify that `P` is prime.

Finally, we need to solve the DLP to get the shared secret, either by solving for `ak` in `A = ak*gen` or for `bk`. The first things I looked for was the order of `gen` in the group over the curve, which I quickly found to be `P`, as it is clear that there are `P` valid points on the curve(one for each integer 0 to P-1 as the x coordinate), and the order of any subgroups of the curve's order would have to divide that. `P` is a prime, so naturally `gen` should be of order `P`. This intuition is further led on by the `gen_key` function, which should ideally generate a unique point for each `sk` randomly chosen. I also checked that `P*gen = zero` to confirm. Next, I tried finding a group homomorphism from the points on `curve` to `Fp`, but I gave up after a while.

At this point, I decided to do some testing to see if any vulnerability with the curve would show up. I wrote the function `get_point` to give me the point associated with an x coordinate, and checked that it worked with all of the given points. Then, I tried multiplying points with x coordinates differing by 1. It turns out that multiplying a point with x coordinate `x` by `n` and multiplying a point with x coordinate `x + 1` by `n` resulted in points with x coordinate differing by `n`, meaning that the x coordinate of results of point multiplication is a linear function of input point's x coordinate. Following this, I tested multiplying the `gen` point by consecutive integers, and found that their x coordinates all had a common difference `diff` mod p from one point to the next. This makes it trivial to solve the DLP, as we can rewrite `A = ak*gen` into `A[0] = G[0] + (ak-1)*diff mod p`. Rearranging to solve for `ak`, we get `(A[0] - G[0])*diff^-1 + 1 = ak mod p`. We then use `ak` to get the shared secret and decrypt the ciphertext.

Solution script:
```python
from Crypto.Util.number import long_to_bytes, bytes_to_long
from Crypto.Util.Padding import unpad
import hashlib
from Crypto.Cipher import AES
from params import A,B,ct
from gmpy2 import is_prime
from libnum import invmod
import random

class Curve:

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def add(self, p1, p2):
        if p1 == self.zero:
            return p2

        if p2 == self.zero:
            return p1

        x1, y1 = p1
        x2, y2 = p2

        if x1 != x2:
            l = (y2 - y1) * invmod(x2 - x1, P)
        else:
            l = 2 * self.a * x1 + self.b #curves of the form y = ax^2 + bx.. but this doesn't have the nice addition property, does it?

        x = ((l - self.b) * invmod(self.a, P) - self.zero[0]) % P
        y = ((x - self.zero[0]) * l + self.zero[1]) % P

        return (x, y)

    def mul(self, p1, n):
        if n == 0 or p1 == self.zero:
            return self.zero

        res = self.zero
        while n:
            if n & 1:
                res = self.add(res, p1)
            p1 = self.add(p1, p1)
            n >>= 1
        return res

    def gen_key(self):
        sk = random.randint(1, P)
        pk = self.mul(self.gen, sk)
        return sk, pk


a = 338105350242668308929697763396044301660
b = 70631159681042046635446173236982478064116538177970218795092411634131296885767
zero = (9754705134713370500425418962906364916694128219443986534870265438313712052553913556304578048773182865236181393234774811636563665254738358548547686098321918938336999994543320310489785839068889289585561389237322554300534800377365494547910434446171077511660646734142974631896227159038644834795595939445003783184271907835168083982210804135992472981458997056367475361358045062954295385753362817510369968941277639065938619221482008127361125972584968230982231483416783792258479416113581249377750311129019561848383083514672254514692875070293706012921153875918378772956871354902564753931679232128607231527456371560574893648150, 1568631189076775839914050721386821274436631828518639911590203429753674249963724465949098434816249858592209181914562366684848647341809527620103035336678319490054708958682690371323396425059326761139960520329829342510826324634871361342587962617109233961205192373716747727013613655062002124851676969800006190929713777159839273173689438005523473921392011053323705509027606365967531781465002057406686284573053674133382181877418753925610208463393821516137543581472014268533517599374830226690216017114664929426655189944119312800402788151756994817725042844409983509754618168400455155658767237036605650525875166823462486072842)
gen = (12532998589621080097666945122441206260965625062664570083674602252675892295679594034580389931735096079697125441246960301905307858329289188790029626634485829771734823159182904621402737540757430079518142479215838577833498703259391220160619426650385355407344355318793784733990238754982178179201863773450543367485332580658467529082154218982726945799974265641603861234501912638573835723384717842487988638277214429988591192513007462677389252245306874828268739787612245357189986581131725474432904172834643657027954405787429995826738074015516166702962206858859896933459093477305874443350335332968385035927605359630747331204285, 9677982578222119974363478748399786948047636069661692206522662047830643067492306311529114015320387572903840619331518584584400368845497864412752196098241604714699115186432809693851692194762433385961429711487895639093866274072187416400859677893102613898063134064507994013600600120524875666883108971040402000931357050726739367647257578379098507781478457700720118945453670136245178829199722575486626106268256525611370267664890630521019846806960099333376121482220389744953231843397729642415527736926160072478730239575933321480584291410141867063436921546657245313608614224909988684794138541856898030369431518091733072867437)

curve = Curve(
    a=a,
    b=b,
    zero=zero,
    gen=gen,
)

def get_kp(point):
	return a * (pow(point[0],2) - pow(zero[0],2)) + b * (point[0] - zero[0]) + zero[1] - point[1]

def get_point(x):
	return (x % P,(a * (pow(x,2) - pow(zero[0],2)) + b * (x - zero[0]) + zero[1]) % P)

assert get_point(A[0]) == A and get_point(B[0]) == B and get_point(gen[0]) == gen

v1 = get_kp(A)
v2 = get_kp(B)
v3 = get_kp(gen)

kp = Integer(gcd(v1,v3)) #small multiple of P
#after factoring kp
P = 16964155551072495694293641975607630224727620299506094680698561697517114055981456463802735036670824528486635128253757386796419676408241481233714972382812783160754601985902695360703612064223677630625126592834772106201583720344150312382723959316671117708799304253580291408927697557459674805267132980104779404642276846095233729275890317878916892907703929715499923974553217760175425647369679697361138159243363407958468903965694813367459663590914481184614924748816307473556323329341018650081832249242635801731713869201574073433674020290004290751530577883843107369211669006291178070342858539229191025760918841972906522445981
assert is_prime(P) #P recovered!
assert zero == curve.mul(gen, P) #order of gen is P


points = {}
start = random.randint(1,P)
xs = {}

for i in range(1,10):
	xs[i] = curve.mul(gen, i)[0]

diffs = [(xs[i] - xs[i-1]) % P for i in range(2,max(xs) + 1)] #constant diffs
diff = diffs[0]

ak = (1 + (A[0] - gen[0])*invmod(diff,P)) % P #From Ax = Gx + (a-1)*diff mod P
assert curve.mul(gen, ak) == A

shared = curve.mul(B, ak)[0]
key = hashlib.sha256(long_to_bytes(shared)).digest()
aes = AES.new(key, AES.MODE_ECB)
flag = unpad(aes.decrypt(long_to_bytes(ct)),AES.block_size)
print(flag) 
```
`RWCTF{parab0la-curv3_1s_far_fr0m_g00d_en0ugh}`